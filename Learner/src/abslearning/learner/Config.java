package abslearning.learner;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.LinkedHashMap;  // for yaml dictionaries
import java.util.LinkedList;     // for yaml lists
import java.util.Properties;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;

import sut.info.SutInfo;
import util.ExceptionAdapter;
import abslearning.exceptions.ConfigurationException;
import abslearning.exceptions.Messages;




/*
 
IMPORTANT
    in config.yaml
      learning_sutinfoFile     : path relative from config.yaml file
      learnResults_outputDir   : path relative from current working directory
      logging_logDir           : path relative from learnResults_outputDir   
*/

public class Config extends util.Config {
	private static final Logger logger = Logger.getLogger(Config.class);


	// config params 	
	public String learning_sutinfoFile; // path relative from config.yaml file
	public int learning_maxTime=0;  // maxtime in seconds. Where 0 means no maxtime.

	public long testing_seed=123;	
	public int testing_minTraceLength=5;
	public int testing_maxTraceLength=20;
	public int testing_maxNumTraces=100;
	
	
	public String sutInterface_sutWrapperClassName="SutSocketWrapper";
	public int  sutInterface_portNumber=18200;
	
	// for sut with inputActions with params we can flatten the alphabet to just a set of
	// actions without parameters. For each action we loop over a range of values for each param,
	// and for each combination of params we create an action which has no params , but has
	// the params set in its string name
	//
	// Note: if min=max then flatten is disabled
	public int   sutInterface_flattenAlphabet_minValue=0;
	public int   sutInterface_flattenAlphabet_maxValue=0;



	public String learnResults_outputDir="output/${timestamp}_${sutname}"; // params are filled in dynamically 
	public String learnResults_abstractModelDotFile="learnedModel.dot";
	public String learnResults_abstractModelPdfFile="learnedModel.pdf";
	public boolean learnResults_writeAbstractModelPdfFile=true;
	public String learnResults_statisticsFile="statistics.txt";
	public String learnResults_statisticsJsonFile="statistics.json";

	
    // general log dir
	public String logging_logDir = "log/";		     
	// configure which logging messages are used where
	public String logging_logFile = "log.txt";	
    public String logging_logFileThreshold = "debug"; // if "off" nothing is logged to file, enable it to log everything by setting it to "debug";		    
	public String logging_consoleThreshold = "info";		    
    // configure which logging messages are generated 
	public String logging_rootLoggerLevel = "info";		    
	public LinkedHashMap<String,String> logging_childLoggerLevels;
    	    
	// extra log4j properties
	public LinkedHashMap<String,String> logging_log4jExtraProperties;		    
		    
	// special logs
	//  - not generated by log4j
	public boolean logging_special_hypotheses = false; 
	public boolean logging_special_hypothesesWritePdf = false; 	
	//  - generated by log4j	
	public boolean logging_special_memQueries = false;
	public String logging_special_memQueriesFile = "memQueries.txt";
	public boolean logging_special_equivQueries = false;
	public String logging_special_equivQueriesFile = "equivQueries.txt";	
	public boolean logging_special_memTraces= false; 
	public String logging_special_memTracesFile= "memTracesFile.txt";
	public boolean logging_special_equivTraces= false; 
	public String logging_special_equivTracesFile= "equivQueryStatisticsFile.txt";
	
	
		
	// original params given for learning
	public LinkedList<String> params_originalArgs;
	public String params_configFile;	
	public String params_tomteRootPath;
	public int params_verboseLevel=0;
	
	
	public ArrayList<String> dependency_extraPaths;  // get prepended to PATH so that they have higher priority
	public String dependency_pythonCmd="python";
	//public String dependency_javaCmd="java";
	//public String dependency_javacCmd="javac";

			
	
	// only for development :
    //------------------------
	public boolean devel_modeOn = true;  
	// production mode by default
	// for now only difference is that in development mode the stacktraces of exceptions are printed

	public boolean devel_runInEclipse = false;  


	
	
	public Config(String[] args) {
		 //String configFile=default_configFile;
		 String configFile=null;
		
		
		// manual read in commandline args  		
       Commandline.handleArgs(args);
       

		// TOMTE_ROOT_PATH : root path where tomte is installed ( in development this folder is also an eclipse project )
		//  - if called by eclipse this is the current working directory  -> we can just simply use "" as TOMTE_ROOT_PATH
		//  - if called not by eclipse we have to supply it as an option :  --tomte-root-path  dir	
        // For example is needed to read the release version of tomte!
		if (Commandline.tomteRootPath != null  )  {
			params_tomteRootPath=Commandline.tomteRootPath;
		} else {
			params_tomteRootPath=(new  File("")).getAbsolutePath(); // current working directory			
		}    
		
		if (  Commandline.verboseLevel > 0 ) params_verboseLevel = Commandline.verboseLevel; 

       
       // read in config
	   configFile=Commandline.configFile; 
       readConfig(args, configFile);		
       params_configFile=configFile;
       //params_originalArgs=new ArrayList<String>(Arrays.asList(args));
       params_originalArgs=new LinkedList<String>(Arrays.asList(args));
       

 
       // cmdline options overrule config options :
       if (Commandline.seed != 0  )  testing_seed=Commandline.seed;
       if (Commandline.maxNumTraces != 0  )  testing_maxNumTraces=Commandline.maxNumTraces;
       if (Commandline.minTraceLength != 0  )  testing_minTraceLength=Commandline.minTraceLength;
       if (Commandline.maxTraceLength != 0  )  testing_maxTraceLength=Commandline.maxTraceLength;
       if (Commandline.outputDir != null  )   learnResults_outputDir=Commandline.outputDir;
       if (Commandline.portNumber != 0  )  sutInterface_portNumber=Commandline.portNumber;
       
       
       // ineclipse property should be set in eclipse IDE in :
       //    menu->Window->Preferences->Java->Installed JREs
       //        -> Click Edit for active VM -> add in textbox "Default VM Arguments" : 
       //              -Dineclipse=true
       String inEclipse=System.getProperty("ineclipse");
       if ((inEclipse == null) || (!inEclipse.toLowerCase().equals("true"))) {
    	   devel_runInEclipse=false;
       } else {
    	   devel_runInEclipse=true;
       }  
    	 
       
   }  
	
   void validate() {    
       
 
       // validate config params 
       //-------------------------
       
       // add extra paths to PATH environment variable
	   if ( dependency_extraPaths != null ) {
	       for ( String path : dependency_extraPaths ) {
	    	   util.Os.prependToPath(path);
	       }
       }
       // tomte commands should be normally in tomteRootPath/bin/ 
       util.Os.prependToPath(params_tomteRootPath + "/bin/");
       // note: but that can be overridden in one of the above extraPaths

       
       // basic requirements 
       //dependency_javaCmd=util.Check.programExist(dependency_javaCmd);
       dependency_pythonCmd=util.Check.programExist(dependency_pythonCmd);
       
       
		// validate config parameters
		// -------------------------------	
		if (testing_maxTraceLength < testing_minTraceLength) {
			throw new ConfigurationException(Messages.WRONG_TESTING_VALUES);
		}       
       
 	}


	public  void init() throws FileNotFoundException {
		
		Config config=this;
		config.validate();
		

		
		// determine SUT name and timestamp which are needed for naming  output/log dir
		// ----------------------------------------------------------------------------
		String sutName = getSutName(config);
		SutInfo.name=sutName;  // will be obsolete later when we better generate sutinfo file
		String timestamp = util.Time.getTimestamp().replace(':', '.');
		// note timestamp has ':' which is not allowed in directory names
		
		// init outputDir and Logging 
		//---------------------------
		//  - initializes logging
		//  - for that it most create an output folder which is parameterized with sutname and timestamp
		//  - it writes the current config with the original output and log folder in the new created output folder
		//  - then it adapts the config with the new parameterized output and log folder 
		String outputDir=initOutputDir(config.learnResults_outputDir,sutName,timestamp);
		String logDir=initLogging(config, outputDir);		
		
		logger.info("SUT name: " + sutName);
		logger.info("output dir: " + outputDir);
		logger.info("log dir: " + logDir);		
		
	
		
		// log original and effective config file and switch config to timestamped outputDir and logDir
		// --------------------------------------------------------------------------------------------
		config.logging_logDir = logDir;
		config.learnResults_outputDir = outputDir;		
		
		
		// setup learnlib logging
		// -------------------------------------------------
		// LearnLog.addAppender(new PrintStreamLoggingAppender(LogLevel.INFO,
		// System.out));
		/*
		 * try { LearnLog.addAppender(new HtmlLoggingAppender(LogLevel.DEBUG,
		 * "/tmp/learn.html", false, false, false)); } catch (IOException e1) {
		 * // TODO Auto-generated catch block e1.printStackTrace(); }
		 */		
						
	}


	/**
	Returns true if it appears that log4j have been previously configured. This code
	checks to see if there are any appenders defined for log4j which is the
	definitive way to tell if log4j is already initialized */
	public static boolean isLog4jConfigured() {
	    Enumeration<?> appenders =  Logger.getRootLogger().getAllAppenders();
	    if (appenders.hasMoreElements()) {
	        return true;
	    }
	    else {
	        Enumeration<?> loggers = LogManager.getCurrentLoggers() ;
	        while (loggers.hasMoreElements()) {
	            Logger c = (Logger) loggers.nextElement();
	            if (c.getAllAppenders().hasMoreElements())
	                return true;
	        }
	    }
	    return false;
	}






	public static String getSutName(Config config)  {
		   // determine SUT name		
		   String sutName;
				
				// check if sutinfo file is set in config
				if (config.learning_sutinfoFile == null
						|| config.learning_sutinfoFile.equals("")) {
					throw new ConfigurationException(Messages.NO_SUTINFO_FILE);
				}
	
						
	            // For normal SUT we get an sutinfo file which must describe SUT name. 
				// - read in information given about sut from SutInfo.yaml file
				// -  config.learning_sutinfoFile is taken as path relative from config dir
				// TODO: also allow absolute path for config.learning_sutinfoFile
				// TODO: add check file is readable
				String configDir = (new File(config.params_configFile)).getParent();
				System.err.println("config.learning_sutinfoFile: " + config.learning_sutinfoFile);
				String filePath = configDir + "/" + config.learning_sutinfoFile;
				System.err.println("configDir: " + configDir);
				System.err.println("reading  sutinfoFile: " + filePath);
				SutInfo.loadFromYaml(filePath);
				config.learning_sutinfoFile = filePath;
	
				// sutinfo.yaml specifies model name!
				// Thus retrieve modelname from sutinfo.yaml file :
				sutName = SutInfo.getName();
						    
		    return sutName;
	}




	public static String initOutputDir(String parameterizedOutputDir,String sutName,String timestamp) throws FileNotFoundException {
	    String outputDir;
	
	    // create output directory
		// ----------------------------------------------
		// output directory can be parameterized with :
		// ${timestamp} : dynamically generated timestamp which allows you to
		// store output in a per execution unique directory
		// so that results of previous executions are never overwritten
		// ${sutname} : to quickly see name of sut in output directory
		outputDir = parameterizedOutputDir.replace("${timestamp}",
				timestamp).replace("${sutname}", sutName) + "/";
	
		
		// reuse existing output dir if possible, or just make new one
		if ( util.Filesystem.isexisting(outputDir) ) {
			if ( util.Filesystem.iswritabledir(outputDir) ) {		
		   	   System.out.println("WARNING: deleting existing output directory : " + outputDir);
			   util.Filesystem.rmdirhier(outputDir);
		    } else {
		     	throw new ConfigurationException("problem creating directory: " +  outputDir);
		    }
		}
	    util.Filesystem.mkdirhier(outputDir);
		
	    // create <outputDir>/input/ 
		util.Filesystem.mkdirhier(outputDir + "/input/");		
		return outputDir;
	}




	public static String initLogging(Config config, String outputDir) throws FileNotFoundException {	
		
		// initialize logging
		// -------------------------------------------------
	
		// logging dir is specified relative output dir
		String logDir = outputDir + config.logging_logDir + "/";		
		
		Properties properties = new Properties();
		
		// set params in log4j config which can be used in log4j config file
		// -> make is possible to use the logDir set in the config.yaml file in the log4j config file! 
		properties.setProperty("logDir",logDir);
		properties.setProperty("logFile",config.logging_logFile);
	    // threshold for console and default log file  
		properties.setProperty("logFileThreshold",config.logging_logFileThreshold);		
		properties.setProperty("consoleThreshold",config.logging_consoleThreshold);
		
		// special logfiles
		properties.setProperty("memQueriesFile",config.logging_special_memQueriesFile);
		properties.setProperty("memTracesFile",config.logging_special_memTracesFile);
		properties.setProperty("equivQueriesFile",config.logging_special_equivQueriesFile);
		properties.setProperty("equivTracesFile",config.logging_special_equivTracesFile);	
		
	
		// configure rootLogger with its appenders 
		properties.setProperty("rootLogLevel",config.logging_rootLoggerLevel);
		String rootAppenders="";
		if (config.logging_consoleThreshold != "off" ) {
			  rootAppenders=rootAppenders + " , console";
		}
		if (config.logging_logFileThreshold != "off" ) {
			  rootAppenders=rootAppenders + " , log_file";
		}				
		properties.setProperty("rootAppenders",rootAppenders);
		
				
		try {
			  Properties properties_adv = new Properties();
			  properties_adv.load(new FileReader(config.params_tomteRootPath + "/config/log4j.conf"));
			  properties.putAll(properties_adv);				
			  
			  if (config.logging_childLoggerLevels != null) {
					//System.err.println(config.logging_loggerAndLevel);
					for ( String key : config.logging_childLoggerLevels.keySet() ) {
						//System.err.println("log4j.logger." + key + "="+config.logging_loggerAndLevel.get(key));
						properties.setProperty("log4j.logger." + key,config.logging_childLoggerLevels.get(key));
					}
			  }	
		      // enable loggers based on config
			  if ( config.logging_special_memQueries ) {
				  properties.setProperty("log4j.logger.memQueries","debug, memQueries_file");
			  }	
			  if ( config.logging_special_equivQueries ) {
				  properties.setProperty("log4j.logger.equivQueries","debug, equivQueries_file");
			  }	
			  if ( config.logging_special_memTraces ) {
				  properties.setProperty("log4j.logger.memTraces","debug, memTraces_file");
			  }	
			  if ( config.logging_special_equivTraces ) {
				  properties.setProperty("log4j.logger.equivTraces","debug, equivTraces_file");
			  }				  
	
		} catch (IOException e) {
			throw new ExceptionAdapter(e);
		}
		
	
		// extra properties are always added
		if (config.logging_log4jExtraProperties != null) {
			//System.err.println(config.logging_log4jExtraProperties);
			properties.putAll(config.logging_log4jExtraProperties);	
		}		
		
		PropertyConfigurator.configure(properties);
		//properties.save(out, comments)
		//properties.list(System.out);
		PrintWriter log4jStream=util.Filesystem.getUtf8FilePrintWriter(outputDir + "/input/log4j.conf");
		properties.list( log4jStream );
		log4jStream.close();
	
		
		util.Filesystem.mkdirhier(logDir);
		if (config.logging_special_hypotheses)
			util.Filesystem.mkdirhier(logDir + "/hypothesis/");
		
		return logDir;
	
	}


	
	
}

